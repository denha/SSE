parts played by different users
Entity 1. USER
Users-> data owners, 
1.No.Files[W]  hash of each keyword W. forinstance two files contain 5 keywords
{
word1:hash
word2:hash
word3:hash


}

2.No.Search[W], number of times a keyword[w] has been searched
3.Dict. maping between keywords and Encrypted filenames.

NOTE: both No.FIles[w] and No.Search[w] are size O(m) m: is the total number of keywords
size of Dict is O(N)=O(nm) where n is total number of files.

Data owners sends No.Files[w] and No.Search[w] 
Dict is outsourced to a CSP

ENTITY 2. CSP
1.the csp stores The cipherTexts
2.A dictionary Dict generated by a data owner. Each address on dictionary is computed using a diffrent key Kw
given the key kw and the No.Files[w] for a keyword w, the CSP can locate all the files that contain w.

ENTITY 3. TRUSTED AUTHORITY (TA) 
stores No.Files[w] and No.Search[w] indexes generated by the dataowner
Note. for a user to create a consistent search token for a keyword w, she must first contact TA in order to get access to the correposnding 
No.Files[w] and No.Search[w] values. Ta is also SEV enabled.

ENTITY 4. Deletion Authority (DelAuth)
he deletes files. Everythime a user peforms a search operation, the CSP forwards the results R to  DelAuth,
DelAuth decrypts the results, removes DICT entries to be deleted and then re-encrypts the remaining filenames and sends them back to the CSP.
LIKE CSP and TA, DelAuth is also SEV enabled.


Data owner u encrypts collection of files f under SSE key KSKE and stored 
them on the CSP.

data owner u allows another user uk to access her files in f by sharingkSKE

now uk can search directly on ui 's encrypted data.


important steps

for anther user to search the words, first hashes the keyword w that wisheds to search for and sends 
h(w) to TA, upon rectpion. TA retries no.Files[w] and No.Search[w] .
it can create the search token ts(w). . 
The search is token is then forwared to the CSP, who uses it to finall a
dict enteres associated with w.


SETUP 
data owner generates the secret Key K. 

1. genreate Kg
2.genrate KSKE
3. return K
4. send KG to TA and K to delAuth
5.delcare C Dict
6. delcare Allmap Dic
7. for all fi do
8. RUN UPDATE ALGO with ADD OPP to generate cfi, cipher filename and MAP 
cfi = (KSKE, fi)
9. c= cU cfi
10.AllMap = [{AllMap ∪ Mapi}, cid(fi)
11.send (Allmap and c ) to CSP
12. send InTa = {no.Files,No.Search} to Ta
13. CSP stores AllMap in InCsp = DIcT


UPDATE ALGO
1if the opperation is to add a file.
2
3. for all distinct keyword[wij] in each File  fi
4.increment one to each keyword[wij]
5.use the function GenIPRF() and key KG, to generate KWiJ by concat hash of a unique keyword and no of search of that keyword
6.generate keyword address by concatin kwij and no.files[wij]
7.Generates the value of keyword by encrypting id of filename concat with No.file(wij) using KSEK keygerated  earlier 
8.store address and val to Map Dictionary
9.encrypt filename with KSKE cfi
10. creation of add token which is sent to CSp, its a combination of cfi and Map

ELSE
OPERATION == DELETE
11. instiate the search protocol for a keyword wj
12.After DelAuth forwards R to the user
R refers to the set of ciphertexts (cid(fj)) that were received by the user after the DelAuth component forwarded the decrypted search results to the user.
13. for every forwareded R refers to the set of ciphertexts (cid(fj)) that were received by the user
14. there is decryption to get the filename ID. (Dec(KSKE, cid(fj )) → id(fj ))
15 checking whether there exists a file in the local buffer that was deleted previously.
16. declare a delte dict
17/compute No.search[wj] from kwj
Kwj = G(KG, h(wj) || No.Search[wj])

Thus, to extract No.Search[wj] from Kwj, we need to reverse this process. Specifically, we need to extract the portion of Kwj that was derived from No.Search[wj]. One way to do this is to hash wj using the same hash function h used to derive Kwj, and then append it to No.Search[wj] to obtain the input that was used to generate Kwj. Once we have this input, we can feed it into G along with KG to obtain Kwj. Finally, we can extract No.Search[wj] from Kwj as follows:

No.Search[wj] = Kwj mod No.Files[wj]

Here, mod represents the modulo operator, which returns the remainder when Kwj is divided by No.Files[wj]. This gives us the value of No.Search[wj] that was used to generate Kwj, which we can then use for subsequent operations.
18.No.files[wj]--
19.No.Search[wj]++
20.use the function GenIPRF() and key KG, to generate KWiJ by concat hash of a unique keyword and no of search of that keyword
21.for i = 1 to i = No.Files[wj] − 1 do
22.create new address
23.create new value
24.ldel={newaddress,newvalue}
25 else its not in the local buffer that was deleted
26.Specifically, τd(f) is a message that contains a list of addresses (Lup) that correspond to the keyword wj and a specific file with an identifier f'. The CSP uses this information to delete the entry for file f' associated with keyword wj from its dictionary.
27.CSP
delete all dict entries associated with wj and inserts the address continaed int Ldel

28. user. Update the local index in send ack to the TA to update its Index as well











SEARCH OPP
1.User sends h(wj) to the TA (trusted Authority)
2.use the function GenIPRF() and key KG, to generate KWiJ by concat hash of a unique keyword and no of search of that keyword 
3.Declare Lookup Dictionary
4.increament serach[wj]++
5.repeat line 2 to get kwj1
6.loop 
get address1 by hashing (Kw,i)and the value of i
7. send Lup = Lup ∪ {addrwj
}
9.the search token τs(wj) is generated as a tuple (Kwj, No.Files[wj], Lup), and is sent to the CSP


WHAT THE CSP DOES ON RECEPTION OF SEARCH TOKEN

10. Declares Rwj {} dict
11. foreach index of no.files of a specific keyword 
12. store values of keyword Valwj= Dict[h(kw,),i)  store hashed keyword and its index in dictionary
Rwj is a list of encrypted files associated with the keyword wj that the user is searching for.
The operation "Rwj = Rwj ∪ {valwj}" appends the value valwj, which is the encrypted file ID along with the number of files, retrieved from the Dict, to the list Rwj.

In other words, for each file i containing the keyword wj, the corresponding encrypted file ID and number of files are retrieved from Dict and added to the list Rwj.
13.Rwj= rwj U{valwj}
14.Forward Rwj and Kwj to the DelAuth

15. DELAUTH
16. sends Rwj to the user and an ack to the CSP.

CSP
17. Delete all the dict entries associated with wj and insert the address contained in Lup




